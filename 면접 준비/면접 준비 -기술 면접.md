## 클로저(Closure)
클로저는 함수와 그 함수가 선언될 때의 렉시컬 환경을 기억하는 매커니즘이다.
외부 함수가 내부 함수보다 먼저 생명주기가 끝나더라도 내부 함수가 외부 함수의 변수를 참조할 수 있게 한다.
-  **클로저의 특징**
	- 데이터 은닉과 캡슐화를 가능하게 한다.
	- 함수 팩토리를 구현하는 데 사용된다.
	- 상태를 안전하게 보존하고 특정 함수에게만 상태 변경을 허용할 수 있다.

  - 💡 렉시컬 환경(Lexical Environment)
    렉시컬 환경은 코드가 작성된 그 문맥을 의미
    즉, 변수와 함수가 선언된 위치에 따라 결정되는 스코프와 그 스코프에 존재하는 식별자들을 말한다.
    ```js
    function outer() {
	  let a = 1;
		  function inner() {
			  console.log(a);
		  }
	  return inner;
	}
	```
	여기서 `inner` 함수의 렉시컬 환경은 `outer`함수이다.
	이 환경에서 변수 `a`가 포함되어 있다.
	
-  💡생명주기에 대한 설명
		Js의 생명주기는 변수가 생성되고, 사용되며, 소멸되는 과정을 말한다.
		1. **선언 단계:** 변수가 스코프에 등록된다.
		2. **초기화 단계:** 변수에 메모리가 할당된다.
		3. **할당 단계**: 변수에 실제 값이 할당된다.
		4. **사용 단계**: 코드에서 변수가 사용된다.
		5. **소멸 단계**: 변수가 더 이상 필요하지 않을 때 가비지 컬렉터에 의해 메모리에서 제거된다.
		모든 값은 저장되기 위한 저장소가 필요한데, 이를 스코프라 칭하고. 스코프는 이러한 생명 주기 동안 변수가 존재하는 범위를 결정해준다.
		
- 💡클로저가 외부 함수 변수를 참조할 수 있는 이유
	클로저는 함수가 생성될 때의 렉시컬 환경을 기억한다. 이는 Js 엔진이 함수를 생성할 때 함수의 `[[Environment]]` 라는 내부 속성에 현재의 렉시컬 환경에 대한 참조를 저장하기 때문.
	```js
	function outer() {
		let count = 0;
		retunr
	}
	```
    

***
## 호이스팅(Hoisting)
호이스팅은 JavaScript에서 변수나 함수 선언이 그 스코프 내에서 최상단으로 끌어올려지는 것처럼 동장하는 특성이다.
이로 인해 코드에서 변수를 선언하기 전에 참조할 수 있는 것처럼 보이는 현상을 발생한다. 하지만 선언만 끌어올려지며, 초기화는 끌어올려지지 않는다.

- 주요 특징
	- 변수와 함수의 선언만 끌어올려지며, 초기화는 끌어올려지지 않는다.
	- `var`, `let`, `const`에 따라 호이스팅 동작이 다르다.

***
## var, let, const
- `var`: 함수 스코프를 가지며, 선언과 초기화가 동시에 이루어진다.
- `let`, `const`는 블록 스코프를 가지며, 선언 단계에서만 호이스팅이 된다.

```js
console.log(x); // undefined
var x = 5;

console.log(y); // ReferenceError
let y = 10;
```
- 따라서 `var`로 선언하기 전에 해당 변수를 `console.log` 해보면 할당된 undefined가 출력되고
- `let`, `const`로 선언하기 전 해당 변수를 consoel.log 해보면 Reference Error가 출력 된다.

***
## 콜백 지옥이란?
여러 개의 비동기 작업이 연달아 발생할 때 콜백 함수가 중첩되어 코드가 복잡해지는 현상입니다. ES6에서 도입된 Promise나 async awiat을 사용하면 보다 간단하고 직관적인 구조로 비동기 코드를 작성할 수 있어 콜백 지옥을 방지할 수 있습니다.

## Promise에 대해 설명해주세요.
Promise는 ES6에 등장한 비동기 작업을 관리하기 위해 사용되는 객체로, 비동기 작업의 완료 또는 실패 여부를 추적하고 이를 처리하는 코드를 제공합니다.

Promise는 대기 중(Pending), 완료(Fullfiled), 실패(Rejected) 3가지 상태를 가지며 이를 이용해 비동기 작업의 흐름을 제어할 수 있습니다.
Promise의 then 메서드는 또 다른 Promise를 반환하므로 여러 비동기 작업을 순차적으로 처리할 수 있습니다.

## Typescript 쓰는 이유?
- TypeScript를 사용하는 이유는 코드를 더 안전하고 효율적으로 작성하기 위해서예요. 쉽게 말해서, JavaScript에 더 똑똑한 기능들을 추가한 언어라고 할 수 있어요. 구체적으로 어떤 점이 좋은지 살펴볼게요!

### 1. 정적 타입 시스템으로 사전 오류 탐지
- 자바스크립트는 동적 타입 언어로, 실행 전까지 타입 오류를 잡기 어렵다. Typesciprt는 컴파일 단계에서 타입 오류를 체크할 수 있어서 런타임 에러를 줄이고, 코드 안정성을 높일 수 있다.

### 2. 코드 가독성과 유지 보수성 향상
- 자바스크립트는 타입 정보가 부족해서 변수와 함수의 의도를 명확히 파악하기 어려워 팀원간의 협업의 혼동이 발생할 수 있다. 타입스크립트의 명시적인 타입선언 덕분에 코드의 가독성이 크게 향상되며, 유지보수 시 코드 의도를 파악하기 쉬우며, 대규모 프로젝트에서 타입 시스템은 일관된 코드를 유지하는 데 중요한 역할을 함 

### 3. 최신 Javascript 기능 사용
- 자바스크립트의 최신 문법과 기능은 모든 브라우저에서 바로 지원되지 않기 때문에, 개발자들이 이를 사용할 때 호환성 문제가 발생할 수 있으나, Typescript는 트랜스파일링을 통해 구버전 Javascript로 변환해준다. 이를 통해 최신 기능을 사용할 수 있다.



## useState
- React는 상태 변경 요청을 큐에 넣어두고, 컴포넌트가 다시 렌더링될 떄 이 큐에 담긴 상태를 한꺼번에 처리

## 브라우저 렌더링 과정에 대해
브라우저는 다음과 같은 과정을 거쳐 렌더링을 수행한다.

1. **리소스 요청 및 응답**
브라우저는 HTML, CSS, Javascript, Image, Font File 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.

2. **HTML 파싱과 DOM 생성**
HTML 파서가 HTML 문서를 파싱하여 DOM 트리를 생성한다.

3. **CSS 파싱과 CSSOM 생성**
CSS 파서가 CSS를 파싱하여 CSSOM(CSS Object Model)을 생성한다.

4. **Javascript 파싱과 실행**
브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST(Abstrac Syntax Tree)를 생성하고 바이트코드르 변환하여 실행한다. 
- 이때 자바스크립트는 DOM API를 통해 DOM이나 CSSOM을 변경할 수 있다. 

5. **렌더 트리 생성**
DOM과 CSSOM을 결합하여 렌더 트리를 생성합니다.
JavaScript에 의해 변경된 DOM과 CSSOM도 다시 렌더 트리로 결합됩니다.

6. **레이아웃**
뷰포트 기반으로 렌더트리가 각 노드가 가지는 정확한 위치와 크기를 계산합니다.
렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)을 계산한다.

7. **페인팅**
계산된 레이아웃을 기반으로 실제 화면에 픽셀을 그린다.

### 💡리플로우(Reflow)와 리페인트(Repaint)

> **리플로우**: 레이아웃 변경이 필요할 때 발생한다.
- 요소의 크기나 위치가 변경될 때 전체 문서의 레이아웃을 다시 계산
- 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등
- DOM 요소 추가, 제거 또는 변경
- CSS 스타일 추가, 제거, 변경
- CSS 클래스 추가
- CSS 애니메이션, 트랜지션, 애니메이션의 모든 프레임에서 리플로우 발생
- offsetWidth 와 offsetHeight 의 사용. offsetWidth 와 offsetHeight 속성을 읽으면, 초기 리플로우가 트리거되어 수치가 계산
- 유저 인터랙션으로 인한 hover, 필드의 텍스트 입력, 창 크기 조절, 글꼴 크기 변경, 스타일시트 또는 글꼴 전환 등

>**리페인트**: 시각적 변화만 있을 때 발생한다.
- 색상 변경 등의 스타일 변경 시 실행된다.
- 리플로우 과정이 끝난 후 재 생성된 렌더트리를 다시 그리는 과정

#### Reflow, Repaint 모두 발생 X
cursor, orphans, perspective는 Reflow, Repaint가 발생하지 않습니다.
transform, opacity는 Reflow를 발생시키지 않고 Repaint만 발생시킵니다.

### CSS를 통한 브라우저 렌더링 최적화
- 브라우저가 중간에 리플로우와 리페인트 작업을 다시 하는 건 부담스러운 작업
- 리플로우 - 리페인트 - 레이어 합성이 반드시 순차적으로 실행되는 것은 아님, 각각 변경사항에 따라 각각 실행하고 최종 레이어 합성(Composite Layers) 단계로 진행
- transform, opacity는 리플로우, 리페인트 생략(GPU가 관여할 수 있는 속성 - DOM 트리를 변경하지 않도록 설계되어 있음 - 즉, 브라우저가 상대적으로 쾌적하게 렌더링할 수 있음) 

#### 최적화 예시
- `left`, `right`, `top`, `bottom` - 리플로우, 리페인트가 필요 
→ `trasform: translate(x, y)` - 리플로우, 리페인트 생략, GPU 가속 활용
- `trasform: translate(x, y)` - 레이어 최적화 없음 
→ `trasform: translate3d(x, y, z)` - 레이어 최적화 진행(브라우저는 해당 요소를 그래픽 레이어로 처리)

#### Graphics Layer(↔ Paint Layer)
- 그래픽 레이어는 GPU를 활용하여 이미지로 변환되며 병렬처리에 특화되어 있어 더 빠르게 변환
- 기존 레이어에서 새롭게 분리되어 주변 레이어에 영향 없이 해당 레이어만 빠르게 그리고, 출력할 수 있음
- GPU에서 작업이 이뤄져 CPU와 그래픽 작업을 분리할 수 있어 저사양 기기에서의 CPU 부담을 줄일 수 있음

## DNS에 대해
사용자가 웹 브라우저를 통해 https://www.google.com을 입력하면?

1. 주소 찾기 : 브라우저는 입력한 주소(google.com)에 해당하는 실제 컴퓨터 위치(IP 주소)를 찾아야해요. 먼저 컴퓨터와 가까운 저장소(캐시 - 브라우저 캐시, 운영체제 캐시)에서 이 주소를 찾고, 없으면 DNS 서버에 물어본다. DNS 서버는 전화번호부처럼 도메인 이름(google.com)을 실제 IP 주소(예. 192.0.2.44)로 바꿔주는 역할을 한다.

2. 연결: 브라우저가 IP 주소를 찾으면, 서버와 연결을 시작한다. 이때, 인터넷의 기본 규칙(TCP/IP)을 사용해 데이터를 주고받을 준비를 한다.
   > TCP/IP는 인터넷에서 데이터를 주고받는 기본 규칙을 정한 통신 프로토콜이라 할 수 있다.
   - **TCP: 데이터의 안전한 전송을 책임지는 우편부**
      - 데이터를 작은 조각(패킷)으로 나누고, 전송된 데이터가 목적지에서 순서대로 제대로 도착했는지 확인합니다. 예를 들어, 친구에게 큰 소포를 여러 상자로 나눠서 보내는 과정과 비슷해요. 모든 상자가 제대로 도착했는지 확인하고, 빠진 상자가 있으면 다시 보내는 역할을 해요.
   - **IP: IP (Internet Protocol): 데이터를 목적지로 전달하는 지도**
      - IP는 데이터가 목적지에 어떻게 도착할지 경로를 정해요. 각 패킷이 정확한 주소(즉, IP 주소)를 따라 이동할 수 있도록 길을 안내합니다. 위의 소포를 예로 들면, IP는 각 상자에 목적지 주소를 붙여주는 역할을 하는 거죠.
   
3. 요청 보내기: 브라우저는 Google 서버에게 "이 페이지를 보여주세요!"라는 요청(HTTP 요청)을 보낸다.

헤더(Headers): 요청에 대한 추가 정보를 담아요. 예를 들어, 브라우저 종류나 인증 정보 등이 포함될 수 있어요.

바디(Body): POST나 PUT 요청에서 데이터를 서버로 보낼 때 사용해요. 예를 들어, 로그인할 때 입력한 아이디와 비밀번호가 바디에 포함됩니다.

4. 응답 받기 : Google 서버는 요청을 받은 후, 필요한 데이터를 응답으로 보내줍니다. 이 응답에는 웹 페이지를 구성하는 HTML, CSS, Javascript 파일이 포함된다.

5. 화면에 보여주기 (렌더링): 브라우저는 응답받은 데이터를 읽고, 렌더링 과정을 겪고, 화면에 보여줍니다.

## HTTP 요청이 뭐야
HTTP 요청은 웹 브라우저가 서버에게 "이 데이터를 주세요!"라고 요청하는 메시지라고 생각하면 돼요. HTTP는 Hypertext Transfer Protocol의 약자로, 웹에서 데이터를 주고받을 때 사용하는 약속(프로토콜)입니다.

### HTTP 요청이란?
웹 브라우저가 서버에 무언가를 요청할 때 사용하는 메시지예요. 예를 들어, https://www.google.com에 접속할 때, 브라우저는 Google 서버에 "이 페이지의 내용을 보내줘!"라고 요청을 보냅니다.

### HTTP 요청의 주요 구성 요소
#### 1. 요청 메서드(Method): 요청의 종류를 나타내요.
1. GET: 서버에서 데이터를 가져올 때 사용해요. 페이지를 불러올 때 주로 쓰이는 요청입니다.
2. POST: 서버에 데이터를 보낼 때 사용해요. 예를 들어, 회원가입 시 사용자 정보를 서버에 보낼 때 쓰입니다.
3. PUT: 서버의 데이터를 업데이트할 때 사용해요.
4. DELETE: 서버의 데이터를 삭제할 때 사용해요.

   >PUT과 POST의 차이점을 아시나요? 
   **PUT 메서드는 클라이언트가 서버의 특정 리소스에 데이터를 저장하거나 업데이트할 때 사용**됩니다. **동일한 요청을 여러 번 보내더라도 결과가 동일한 멱등성이 보장**되는 특징이 있습니다. 즉, 동일한 데이터를 같은 URI에 요청을 여러번 보내도 결과는 항상 동일한 리소스가 저장됩니다. (전체 업데이트)
   > **POST 메서드는 서버의 리소스에 데이터를 제출하여 새로운 리소스를 생성하거나 서버에서 특정 작업을 수행할 때 사용**됩니다. 여러 번 요청시 매번 다른 결과를 낼 수 있어 멱등성을 보장하지 않습니다. 예를 들어, 동일한 POST 요청을 여러 번 보내면 새로운 리소스가 그때마다 생성될 수 있습니다. → 리소스를 추가하거나 서버가 정의한 작업을 수행(전체 또는 부분 데이터 제출 가능)
   > **PUT은 특정 리소스를 정확히 지정하고 업데이트하거나 생성**할 때, **POST는 새로운 리소스를 생성하거나 서버에서 정의된 작업을 수행**할 때 유용합니다.

#### 2. URL: 요청할 자원의 주소를 나타내요. 
예를 들어, https://www.example.com/products는 제품 정보를 요청하는 URL입니다.

#### 3. 헤더(Headers): 요청에 대한 추가 정보를 담아요. 
예를 들어, 브라우저 종류나 인증 정보 등이 포함될 수 있어요.

#### 4. 바디(Body): POST나 PUT 요청에서 데이터를 서버로 보낼 때 사용해요. 
예를 들어, 로그인할 때 입력한 아이디와 비밀번호가 바디에 포함됩니다.

### HTTP 요청의 흐름
사용자가 URL을 입력하거나 버튼을 클릭합니다.
브라우저는 서버에 HTTP 요청을 보냅니다.
서버는 요청을 처리하고, 필요한 데이터를 HTTP 응답으로 브라우저에 보냅니다.
브라우저는 받은 데이터를 화면에 표시합니다.

## HTTP와 HTTPS
- 기존 HTTP의 가장 큰 문제점은 오가는 데이터를 암호화하지 않는 부분인데, 중간에 누군가 민감 정보를 가로채거나 할 수 있다는 점입니다. 그래서 HTTPS(Hypertext Transfer Protocol Secure)는 기존의 HTTP에 Secure라는 붙인 것처럼 **확장 버전 또는 더 안전한 버전이**라고 볼 수 있습니다. 
- HTTPS에서는 브라우저와 서버가 데이터를 전송하기 전에 **SSL(보안 소켓 계층)**을 통해 안전하게 암호화된 연결을 만들 수 있게 도와주고, 안전하게 민감 정보를 주고 받을 수 있게끔 합니다.
   > **SSL (Secure Sockets Layer):**
    HTTPS는 SSL 또는 TLS(전송 계층 보안)를 사용하여 데이터를 암호화합니다.
    암호화: 정보를 다른 사람이 볼 수 없도록 변환하는 과정입니다.
    즉, 웹사이트와 사용자의 브라우저 간에 안전한 연결을 만들어줍니다.
    예를 들어, 여러분이 온라인 쇼핑을 할 때 신용카드 번호 같은 민감한 정보를 입력하면, HTTPS 덕분에 이 정보가 안전하게 보호됩니다. 누군가 중간에서 정보를 가로채더라도, 이 암호화 덕분에 읽을 수 없습니다.
- 단순히 민감 정보에 대한 보안을 떠나서라도 HTTP로 접속했을 때 사용자 입장에선 다양한 경고 메세지를 통해서 사용자 경험이 안 좋아질 수 있고, 구글에서도 HTTPS를 권장하고 검색 랭킹 알고리즘에 해당 요소를 반영하겠다 밝혔기 때문에 SEO 측면에서도 중요합니다.


## 실행 컨텍스트
실행 컨섹트는 코드가 실행될 때의 환경을 의미한다.
자바스크립트에서는 실행될 코드가 어떻게 동작하는지 정보를 가지고 있다.
- 변수 환경: 현재 코드에서 사용할 수 있는 변수들을 저장
- 스코프 체인: 현재 코드 블록에서 접근할 수 있는 변수의 범위 결정
- `this` 바인딩: 현재 코드에서의 this의 값이 무엇인지 결정한다.

### this 바인딩 추가 설명
#### 일반 함수의 `this`
일반 함수에서는 this의 값이 함수 호출 방식에 따라 결정됩니다. 즉, 함수가 호출되는 상황에 따라 달라질 수 있습니다.
```jsx
const person = {
    name: 'Lee Ji-won',
    showName: function() {
        console.log(this.name); // 일반 함수에서는 this가 호출된 객체를 참조
    },
    delayedShowName: function() {
        setTimeout(function() {
            console.log(this.name); // 여기서 this는 전역 객체를 참조 (undefined)
        }, 1000);
    }
};

person.showName(); // 'Lee Ji-won' 출력
person.delayedShowName(); // undefined 출력
```
#### 화살표 함수의 `this`
화살표 함수는 `this`를 자신을 포함한 가장 가까운 스코프의 `this`로 결정한다.
화살표 함수는 자신이 정의된 **상의 컨텍스트의 `this` 값을 그대로 사용** 그래서 호출 방식과는 관계없이 `this` 값이 일관되게 유지
```jsx
const personWithArrow = {
    name: 'Lee Ji-won',
    showName: function() {
        console.log(this.name); // 일반 함수에서는 this가 호출된 객체를 참조
    },
    delayedShowName: function() {
        setTimeout(() => {
            console.log(this.name); // 여기서 this는 personWithArrow 객체를 참조
        }, 1000);
    }
};

personWithArrow.showName(); // 'Lee Ji-won' 출력
personWithArrow.delayedShowName(); // 1초 후 'Lee Ji-won' 출력
```

#### 원리 차이
- 일반 함수: this는 **실행 시점**에 결정되며, 함수가 어떻게 호출되었는지에 따라 다르게 바뀔 수 있습니다.

- 화살표 함수: this는 함수가 정의된 시점의 상위 컨텍스트에서 결정되며, 호출하는 방식에 영향을 받지 않습니다. 즉, 화살표 함수는 this 바인딩이 없으며, 주변 스코프의 this를 **렉시컬하게(Lexical) 캡처**합니다.

## 콜 스택(Call Stack)
콜 스택은 실행 컨텍스트를 쌓아두는 구조이다.
함수가 호출되면 실행 컨텍스트가 콜 스택에 쌓이고, 함수 실행이 끝나면 스택에서 제거된다.
실행 컨텍스트가 현재 실행 중인 코드이다.
- 작동 방식
   1. **함수 호출**: 함수가 호출되면 실행 컨텍스트가 콜 스택에 추가된다.
   2. **함수 실행**: 현재 콜 스택의 최상단에 있는 함수가 실행
   3. **함수 종료**: 함수가 실행을 마치면 해당 실행 컨텍스트가 콜 스택에서 제거된다.
   
## 큐(Queue)
큐는 **콜 스택이 비어 있을 떄 실행할 작업을 대기시키는 구조**이다.
주로 비동기 작업의 결과를 처리할 때 사용된다.
- 작동 방식: 비동기 작업이 완료되면 그 결과를 큐에 넣어두고, 이후 콜 스택이 비어 있을 때 해당 작업을 콜 스택으로 이동 시킨다.

## 이벤트 루프(Event Loop)
이벤트 루프는 **콜스택과 큐를 연결하여 비동기 작업을 처리하는 매커니즘**이다.
이벤트 루프는 다음 과정을 거쳐 비동기 작업을 처리한다.

1. 콜 스택이 비어있는지 확인한다.
2. 콜스택이 비어 있다면, 큐에서 대기 중인 작업이 있는지 확인한다.
3. 큐에 작업이 비어있따면 그 작업을 콜 스택으로 이동시켜 실행한다.

> 정리하자면,
   1. 비동기 함수 호출 -> 큐에서 대기 -> 이벤트 루프가 콜 스택을 확인해주고 비어있을 경우에 콜스택으로 이동시켜 실행해줌
   

## 얇은복사 깊은 복사
### 얇은 복사
- 얇은 복사를 하면 객체 최상위 속성은 새롭게 복사가 되지만, 그 속성이 다른 객체를 참고하고 있다면 그 중첩된 객체는 동일한 메모리 주소를 공유하게 된다.
- 즉, 복사한 객체와 원본 객체가 중첩 객체의 메모리 주소를 공유하므로, 한쪽에서 중첩 객체의 속성을 변경하면 다른쪽에도 그 변경 사항이 반영된다.

### 깊은 복사 
- 깊은 복사를 하면 원본 객체의 모든 속성과 중첩 객체를 완전히 새롭게 복사하여 새로운 메모리 주소를 가집니다.
- 이로 인해 복사한 객체와 원본 객체가 서로 영향을 주지 않게 됩니다. 즉, 한쪽에서 중첩 객체의 속성을 변경하더라도 다른 쪽은 영향을 받지 않습니다.

### 왜 얇은 복사와 깊은 복사를 구분해야 할까요?
- 얕은 복사는 메모리 사용이 더 효율적이지만, 중첩된 데이터에 대한 변경이 원본 객체에 영향을 미칠 수 있어 주의해야 합니다.
 - 유저 데이터 같은 경우에 변경이 꼭 필요하니까 사용하지않을가?
- 깊은 복사는 데이터의 완전한 독립성을 보장하지만, 메모리 사용량이 더 많고 성능이 떨어질 수 있습니다.
 - API 응답 받은건 깊은 복사를 많이 사용할 수도 있지않을가?
 
## 쿠키, 웹 스토리지, 세션 차이
### 쿠키 
1. **저장 용량**: 일반적으로 `4KB`까지 데이터를 저장할 수 있습니다.
2. **만료**: `만료일을 설정`할 수 있으며, 만료일이 지나면 자동으로 삭제됩니다. 만료일을 설정하지 않으면 세션 쿠키로 남아 있습니다.
3. **전송**: 매 `HTTP 요청 시 서버로 자동 전송`되며, 사용자가 요청한 도메인에 대해서만 전송됩니다.
4. **용도**: 사용자 인증, 세션 관리, 사용자 설정(예: 테마) 등을 저장하는 데 사용됩니다.
5. **보안**: `HTTPS를 사용할 경우, Secure 플래그를 설정하면 안전하게 전송`니다. HttpOnly 플래그를 설정하면 JavaScript에서 접근할 수 없습니다.

### 웹 스토리지
1. 저장 용량: 각 도메인당 약 `5MB에서 10MB까지` 데이터를 저장할 수 있습니다.
2. 만료: `만료일이 없으며`, 사용자가 명시적으로 삭제할 때까지 데이터가 유지됩니다.
3. 전송: 서버로 자동 전송되지 않으며, `클라이언트 측`에서만 사용됩니다.
4. 유형:
   - 로컬 스토리지 (Local Storage): 데이터를 `영구적으로 저장`하며, 브라우저가 종료되어도 데이터가 유지됩니다.
   - 세션 스토리지 (Session Storage): `브라우저 탭이나 창이 닫히면 데이터가 삭제`됩니다. 같은 탭에서는 데이터가 공유되지만, 다른 탭에서는 사용할 수 없습니다.
5. 용도: 사용자 설정, 임시 데이터 저장 등에 사용됩니다.

### 세션
1. 저장 위치: 일반적으로 `서버에서 관리`되며, 클라이언트에서는 `쿠키를 사용하여 세션 ID`를 저장합니다.
2. 만료: 세션은 사용자가 `브라우저를 종료`하거나 세션 `타임아웃`이 발생할 때까지 유지됩니다.
3. 전송: 세`션 ID가 담긴 쿠키를 사용하여 클라이언트와 서버 간의 세션을 관리`합니다.
3. 용도: 사용자의 로그인 상태를 유지하고, 개인화된 데이터를 관리하는 데 사용됩니다.
4. 보안: 서버에서 세션 정보를 관리하므로, 클라이언트 측에서 직접 접근할 수 없습니다.

## Virtual DOM
버츄얼 돔은 실제 돔의 가벼운 복사본으로, UI 변경사항을 효율적으로 처리하기 위해 사용됩니다.

- 작동 원리:
 1. 변경사항 추적: 애플리케이션의 `상태가 변경`되면, 프레임워크는 `새로운 가상 DOM을 생성`합니다.
 2. 비교: `이전의 가상 DOM`과 `새로운 가상 DOM`을 비교(diffing)하여 어떤 부분이 변경되었는지 파악합니다.
 3. 최적화된 업데이트: `변경된 부분만 실제 DOM에 업데이트(Reconciliation)`합니다. 이렇게 하면 불필요한 DOM 조작을 줄이고 성능을 향상시킬 수 있습니다.
 
 
## Props Drilling이란?
Props Drilling은 상위 컴포넌트에서 하위 컴포넌트로 props(속성)를 전달하는 과정을 의미합니다. 컴포넌트가 여러 단계로 중첩되어 있을 때, 상위 컴포넌트에서 하위 컴포넌트까지 props를 한 단계씩 전달해야 합니다.

```
App
 ├── ComponentA
 │    └── ComponentB
 │         └── ComponentC
```
만약 App 컴포넌트에서 A라는 변수를 ComponentC에 전달하고 싶을 때 ComponentA -> ComponentB -> ComponentC로 전달해야됩니다.

### 문제가 생기는 이유
1. 복잡성: 중간에 있는 ComponentA와 ComponentB는 ComponentC에 전달하고자 하는 데이터에 대해 아무런 관심이 없는데도 불구하고, 이 데이터를 props로 받아서 다시 전달해야 합니다. 이런 상황이 계속 반복되면, 다음과 같은 문제가 발생할 수 있습니다:
2. 가독성 저하: 컴포넌트의 코드가 복잡해지고 이해하기 어려워질 수 있습니다.
3. 유지보수 어려움: 컴포넌트가 깊어질수록 전달되는 props를 추적하기 어려워져서 코드 수정을 하는 데 더 많은 시간이 소요될 수 있습니다.

### 해결 방법
1. Context API: React에서 제공하는 Context API를 사용하면, 전역적으로 데이터를 관리할 수 있습니다. 이를 통해 깊은 컴포넌트 트리 구조에서도 데이터를 쉽게 공유할 수 있습니다. 상위 컴포넌트에서 데이터를 제공하고, 하위 컴포넌트는 이를 쉽게 소비할 수 있습니다.
2. 상태 관리 라이브러리: Redux, Jotai, Recoil 같은 라이브러리를 사용하면 전역 상태를 관리할 수 있습니다. 이러한 라이브러리는 컴포넌트 간에 데이터의 흐름을 더 효율적으로 관리할 수 있게 도와줍니다.

## Context API가 머냐?
Context API는 React에서 전역적으로 데이터를 공유하고 관리할 수 있도록 도와주는 기능입니다. 이 기능을 사용하면 props를 깊게 전달하지 않고도 여러 컴포넌트에서 동일한 데이터에 접근할 수 있습니다.
_~~좀 어려우니까 Context API를 사용하면 Context의 정보를 효율적으로 관리하고 공유할 수 있는 것?~~_


### Context의 개념
Context: Context는 React의 기능으로, 특정 데이터를 컴포넌트 트리의 여러 하위 컴포넌트에 쉽게 전달할 수 있게 해줍니다. 예를 들어, 사용자 인증 정보, 테마 설정, 다국어 지원 등의 전역 상태를 Context를 통해 쉽게 관리할 수 있습니다.
_~~조금 어려울 수 있으니까 컨텍스트는 여러 컴포넌트가 접근할 수 있는 데이터를 포함하는 "환경"이라고 생각하면 될 것 같다..~~_

## CDN이란?
CDN은 콘텐츠 전송 네트워크를 의미합니다. 이는 웹 콘텐츠를 사용자에게 더 빠르고 효율적으로 전달하기 위한 분산된 서버 네트워크입니다.

### 어떻게 작동하나요?
1. 분산된 서버: CDN은 전 세계 여러 지역에 분산된 여러 서버로 구성되어 있습니다. 이를 **엣지 서버(Edge Server)**라고 합니다.

2. 콘텐츠 저장: 웹사이트의 이미지, CSS 파일, JavaScript 파일 등의 정적 콘텐츠를 이 엣지 서버에 저장합니다. 이렇게 하면 사용자가 요청할 때, 가장 가까운 서버에서 콘텐츠를 제공받을 수 있습니다.

3. 빠른 전송: 사용자가 웹사이트에 접속하면, CDN은 가장 가까운 엣지 서버에서 콘텐츠를 가져와서 사용자에게 전달합니다. 이렇게 하면 콘텐츠 로딩 속도가 빨라지고, 사용자 경험이 개선됩니다.

## React 18버전에서는 뭐가 달라졌나요?
React 18에서는 동시성 모드(Concurrent Mode)가 도입되어 긴 렌더링 작업을 중단하고 사용자 입력과 같은 더 중요한 작업을 먼저 처리할 수 있습니다. 자동 일괄 처리 기능(Automatic Batching)이 향상되어 이벤트 핸들러뿐만 아니라 비동기 코드 내에서도 일괄 처리가 가능해졌습니다. 또한 useTransition 훅을 사용하여 상태 업데이트의 우선순위를 구분할 수 있으며, useDeferredValue 훅을 사용해 긴급하지 않은 상태 업데이트에서 이전 값을 사용할 수 있습니다. Suspense 기능도 개선되어 데이터를 가져오는 동안 컴포넌트의 로딩 상태를 더 쉽게 관리할 수 있습니다.

## JSX에서 단일 루트 요소가 안되는 이유
> 단일 루트 요소: JSX에서는 모든 컴포넌트가 단일 루트 요소로 감싸져 있어야 합니다. 즉, 여러 개의 형제 요소를 직접적으로 나열할 수 없습니다. 따라서 `<형제> <형제>와` 같은 형태는 허용되지 않습니다.

1. 가상 DOM 업데이트 최적화
React는 상태 변경 시 가상 DOM을 사용하여 효율적으로 UI를 업데이트합니다. 여러 루트 요소가 있을 경우, React는 어떤 요소가 변경되었는지를 추적하기가 더 어려워집니다. 단일 루트 요소가 있으면 React는 해당 요소를 기준으로 하위 요소들의 상태를 쉽게 관리할 수 있습니다.

2. React의 렌더링 규칙
React는 각 컴포넌트가 단일 값(즉, 단일 루트 요소)을 반환하도록 설계되었습니다. 이는 React의 함수형 프로그래밍 철학에 기반하여, 함수를 통해 복잡한 UI를 간단하게 구성할 수 있도록 하기 위한 것입니다. 여러 루트 요소를 반환하는 것은 이 원칙을 위반하는 것이므로, React의 기본 설계에서 벗어납니다.

## SPA, CSR, SSR, SSG의 개념
SPA는 단일 페이지 애플리케이션으로 초기에 필요한 코드를 모두 로드한 후, 페이지를 다시 로드하지 않고 동적으로 콘텐츠를 업데이트하는 방식입니다.

CSR는 클라이언트 측에서 페이지를 동적으로 렌더링하는 방식입니다. 초기 페이지 로드 후, 클라이언트가 JS를 사용하여 데이터를 가져와 렌더링합니다.

SSR은 서버 측에서 초기 페이지 렌더링을 수행하고, 완성된 HTML을 클라이언트에게 전달하는 방식입니다. 페이지가 서버에서 렌더링되기 때문에 초기 로딩 시간이 단축되고 SEO에 유리합니다.

SSG(Static Site Generation)는 빌드 타임에 모든 페이지를 미리 렌더링하여 정적 파일(HTML, CSS, JS)로 생성합니다. 생성된 정적 파일들은 서버나 CDN을 통해 제공됩니다.

## Next.js의 Image 컴포넌트를 사용하였을 때 기존 img 태그와 다른 점.
Next.js의 Image 컴포넌트를 사용하면 이미지 최적화를 자동으로 처리해 페이지 성능을 향상시킵니다. 또한 이미지 크기를 미리 알고 있기 때문에 레이아웃 시프트를 방지할 수 있고 이미지 로딩 전 홀더 이미지 설정으로 사용자 경험을 향상시킬 수 있습니다.


# 이력서 면접
## 크로스 브라우징 해결
Safari 등 모바일 브라우저에서 100vh 이슈

Safari 등 특히 모바일 브라우저 상에서 노출되는 영역(ex) 주소 영역) 때문에 100vh 적용한 element 위를 덮어버리는 이슈가 있었다. 브라우저 상에서 덮어지는 영역을 제외하고 1vh를 재계산하여 다시 렌더링하는 방식을 취했다. 추가로 불필요한 버그를 방지하기 위해 모바일 메뉴가 나올 때는 body의 scrollbar를 없애서 스크롤이 되지 않도록 적용했다.

## SEO 강화 경험
SEO를 강화하기 위해 메타 태그, 제목 태그, alt 속성을 적절히 사용하여 검색 엔진 최적화에 기여했습니다. 또한, 로딩 속도를 개선하기 위해 이미지 최적화와 코드 분할을 적용하여 사용자 경험과 검색 엔진의 평가를 모두 향상시켰습니다.


[클로저, 생명주기, 스코프, var에 대한 블로그가 잘 정리된 곳이 있다.](https://tang-co.tistory.com/142)
